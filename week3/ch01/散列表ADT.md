#                                            散列表ADT

## 散列函数（散列表ADT的实现）

个人想法：散列表就是将一个个基础的数据结构单位以散列的形式放到表中，而这样的话就需要一格一格的放而且不要有冲突，这样的话可以根据一个函数比如F(i)=i来确定位置。

散列方法的主要思想是根据结点的关键码值来确定其存储地址：以关键码值K为自变量，通过一定的函数关系h(K)(称为散列函数)，计算出对应的函数值来，把这个值解释为结点的存储地址，将结点存入到此存储单元中。

### 问题

（1）如何构造(选择)使结点“分布均匀”的散列函数？
（2）一旦发生冲突，用什么方法来解决？（分离链接法和开放定址法。）

散列的核心就是：由散列函数决定关键码值与散列地址之间的对应关系，通过这种关系来实现组织存储并进行检索。

```

```

每个关键字被映射到从0到TableSIze-1这个范围中的某个数，并且被放到适当的单元中。这个映射就叫做散列函数。理想情况下，散列函数计算简单，并且应该保证任何两个不同的关键字映射到不同的单元。

这些就是散列的基本想法。剩下的事情就是当散列冲突的时候应该做什么以及如何确定散列表大小。

## 分离链接法

其做法是将散列到同一个值的所有元素都放到一个表中，Hash(X)=X mod 10就是一种散列函数，当出现冲突时，在冲突位置放一个链表。缺点是需要指针，分配空间是会有更多的时间荣冗余。

装填因子为为散列表中元素个数对该散列大小的比（类比hashmap的扩容）。选择合适的装填因子可以保证散列表的查找时间。理想的散列装填因子<1时，查找时间为O（1）。

## 开放定址法

如果有冲突发生的话，那么就要尝试选择另外的单元，直到找出空的单元为止。

#### 线性探测法

函数F是i的线性函数，相当于逐个探测每个单元直到查找出一个空单元。只要表足够大总能找到一个自由单元。但同样的花费时间会更多，而且会出现聚集现象。

#### 平方探测法

用来消除线性探测法中一次聚集冲突的问题，冲突函数为二次函数，但仍然有二次聚集。

#### 双散列

双散列（double hashing）。常用的方法是让F（i）= i * hash2( x )，这意思是用第二个散列函数算出x的散列值，然后在距离hash2( x )，2hash2( x )的地方探测。

